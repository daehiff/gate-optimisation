from evaluations import *from utils import generate_random_circuit, get_circuit_statsimport osimport pandas as pdNAME_EVALUATION = {    "default": lambda x: x,    "tket": tket_evaluation,    "qiskit": qiskit_evaluation,    "tpar": tpar_evaluation,    "voqc": voqc_evaluation,    "qfast": q_fast_evaluation,    "pyzx": pyzx_evaluation,}NUM_GATE_COUNTS = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]NUM_QUBITS = [3, 4]T_PROBABILITY = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]CNOT_PROBABILITY = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]STORAGE_ROOT = "circuits"def main():    samples = 1    evaluate_gate_count(num_samples=samples)    evaluate_num_qubits(num_samples=samples)    evaluate_t_pr(num_samples=samples)    evaluate_cnot_pr(num_samples=samples)def evaluate_gate_count(num_qubits=4, num_samples=10):    """    Evaluating num_samples random circuits by increasing num_gates    :param num_samples:    :param num_qubits:    :return:    """    df = pd.DataFrame()    for gate_count in NUM_GATE_COUNTS:        for i in range(num_samples):            print(f"At {i}")            df = random_evaluation(df, f"i_{i}_cnt_{gate_count}", num_qubits, gate_count, subfolder="gate_count")    df.to_csv("gate_count.csv")def evaluate_num_qubits(gate_count=50, num_samples=10):    """    Evaluating num_samples random circuits by increasing num_gates    :param gate_count:    :param num_samples:    :return:    """    df = pd.DataFrame()    for num_qubits in NUM_QUBITS:        print(num_qubits)        for i in range(num_samples):            print(f"At {i}")            df = random_evaluation(df, f"i_{i}_num_qubits_{gate_count}", num_qubits, gate_count, subfolder="qubits")    df.to_csv("num_qubits.csv")def evaluate_t_pr(gate_count=50, num_qubits=4, num_samples=10):    """    Evaluating num_samples random circuits by increasing num_gates    :param num_qubits:    :param gate_count:    :param num_samples:    :return:    """    df = pd.DataFrame()    for t_p in T_PROBABILITY:        for i in range(num_samples):            print(f"At {i}")            df = random_evaluation(df, f"i_{i}_t_pr_{gate_count}", num_qubits, gate_count, p_t=t_p,                                   subfolder="tprob")    df.to_csv("t_pr.csv")def evaluate_cnot_pr(gate_count=50, num_qubits=4, num_samples=10):    """    Evaluating num_samples random circuits by increasing num_gates    :param num_qubits:    :param gate_count:    :param num_samples:    :return:    """    df = pd.DataFrame()    for p_cnot in CNOT_PROBABILITY:        for i in range(num_samples):            print(f"At {i}")            df = random_evaluation(df, f"i_{i}_cnot_pr_{gate_count}", num_qubits, gate_count, p_cnot=p_cnot,                                   subfolder="cnot_pr")    df.to_csv("cnot_pr.csv")def store_circuit(qc: QuantumCircuit, algorithm: str, hash: str, category: str):    """    Store a circuit by    :param qc:    :param algorithm:    :param hash:    :param category:    :return:    """    circ_path = f"{STORAGE_ROOT}/{category}"    circ_name = f"{hash}_{algorithm}"    os.makedirs(circ_path, exist_ok=True)    qc.qasm(filename=f"{circ_path}/{circ_name}.qasm")def random_evaluation(df: pd.DataFrame, circ_hash: str, qubit_count: int, num_gates: int,                      p_t: float = None,                      p_cnot: float = None,                      subfolder: str = "random",                      rebase_ibm: bool = False):    qc = generate_random_circuit(qubit_count, num_gates, p_t=p_t, p_cnot=p_cnot)    for name, evaluation in NAME_EVALUATION.items():        qc_ = evaluation(qc)        if rebase_ibm:            qc_ = rebase_gates_ibm(qc_)        store_circuit(qc_, name, circ_hash, subfolder)        clifford_count, non_clifford, two_qubit_count, overall_gate_count, depth = get_circuit_stats(qc_)        df = df.append({"circuit": f"{subfolder}/{circ_hash}",                        "circ_q_count": qubit_count,                        "circ_num_gates": num_gates,                        "algorithm": name,                        "clifford_count": clifford_count,                        "non_clifford": non_clifford,                        "two_qubit_count": two_qubit_count,                        "overall_gate_count": overall_gate_count,                        "depth": depth}, ignore_index=True)    return dfif __name__ == '__main__':    main()